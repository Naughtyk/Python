"""
Программа, иллюстрирующая множество всех возможных исходов в неантагонистической
биматричной игре для случая некооперативного поведения игроков

Автор: Афанасьев И.Е.
Дата написания: 20.09.2020
"""

# Матрица
#m = [[2, 1], [-1, -1], [-1, -1], [1, 2]]
m = [[4, 3], [-2, -2], [-1, -4], [1, 5]]

# Импортируем библиотеку для поиска экстремумов
from scipy.optimize import minimize

# формула выигрыша первого игрока
def S1(x):
  return m[0][0]*x[0] * x[1] \
+ m[1][0]*(1 - x[0]) * x[1] \
+ m[2][0]*x[0] * (1 - x[1]) \
+ m[3][0]*(1 - x[0]) * (1 - x[1])

# формула выигрыша второго игрока
def S2(x):
  return x[0] * m[0][1]*x[1] \
+ (1 - x[0]) * m[1][1]*x[1] \
+ x[0] * m[2][1]*(1 - x[1]) \
+ (1 - x[0]) * m[3][1]*(1 - x[1])

# Ищем экстремальную точку для первого игрока
res = minimize(S1, [1, 1])
print("Экстремум для первого игрока: ", res.x)

print("Значение выигрыша: ", S1(res.x))

# Ищем экстремальную точку для второго игрока
res = minimize(S2, [1, 1])
print("Экстремум для второго игрока: ", res.x)

print("Значение выигрыша: ", S2(res.x))

# Библиотека для матричных вычислений, нам она нужна для создания
# массива от 0 до 1
import numpy as np

xval = np.linspace(0, 1, 51)
yval = np.linspace(0, 1, 51)

# Библиотека для графиков
import matplotlib.pyplot as plt

x, y = np.meshgrid(xval, yval)
z1 = S1([x, y])
z2 = S2([x, y])

plt.scatter(z1, z2)

plt.show()